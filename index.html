<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>HTML5 Mario-like</title>
<style>
	html,body{margin:0;padding:0;background:#87CEEB;overflow:hidden;font-family:system-ui,Segoe UI,Arial;}
	#game { display:block; margin:0 auto; background:#8ecaff; outline:none; touch-action:none; }
	.hud {
		position:fixed; left:0; top:0; right:0; display:flex; justify-content:space-between;
		padding:8px 12px; color:#111; text-shadow:0 2px 0 rgba(255,255,255,.3); font-weight:700;
		user-select:none; pointer-events:none;
	}
	.hud span{margin-right:12px}
	.overlay {
		position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
		color:#111; text-shadow:0 2px 0 rgba(255,255,255,.3); font-weight:800; font-size:24px;
		pointer-events:none;
	}
	.mobile {
		position:fixed; left:0; right:0; bottom:0; height:36vh; pointer-events:none;
	}
	.stick, .btn {
		position:absolute; background:rgba(255,255,255,.2); border:2px solid rgba(0,0,0,.2); border-radius:12px;
		backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
	}
	.stick{ left:16px; bottom:16px; width:40vw; max-width:300px; height:28vh; max-height:200px; pointer-events:auto;}
	.btn{ right:16px; bottom:16px; width:28vh; max-width:200px; height:28vh; max-height:200px; pointer-events:auto;}
	.dir { position:absolute; width:48%; height:48%; display:flex; align-items:center; justify-content:center; color:#222; font-weight:900; }
	.dir.l{ left:2%; top:26%;}
	.dir.r{ right:2%; top:26%;}
	.dir.u{ left:26%; top:2%;}
	.dir.d{ left:26%; bottom:2%;}
	.btnJump { position:absolute; inset:10% 10%; display:flex; align-items:center; justify-content:center; color:#222; font-weight:900; }
	.badge {
		background:rgba(255,255,255,.65); padding:2px 6px; border-radius:6px; margin-right:8px;
	}
</style>
</head>
<body>
<canvas id="game" width="960" height="540" tabindex="0" aria-label="Mario-like Game"></canvas>
<div class="hud" aria-hidden="true">
	<div><span class="badge">COINS: <b id="coins">0</b></span><span class="badge">LIVES: <b id="lives">3</b></span></div>
	<div><span class="badge">TIME: <b id="time">400</b></span></div>
</div>
<div id="overlay" class="overlay" style="display:none;"></div>

<!-- Mobile controls -->
<div class="mobile" aria-hidden="true">
	<div class="stick" id="stick">
		<div class="dir l" data-dir="left">←</div>
		<div class="dir r" data-dir="right">→</div>
	</div>
	<div class="btn" id="jump">
		<div class="btnJump">JUMP</div>
	</div>
</div>

<script>
(() => {
	const TILE = 32;
	const VIEW_W = 30, VIEW_H = 17;
	const GRAVITY = 0.9;
	const FRICTION = 0.85;
	const MOVE_ACCEL = 0.8;
	const MAX_RUN = 4.2;
	const JUMP_VY = -14.5;
	const MAX_FALL = 18;
	const FLAG_X = 220;
	const WORLD_TIME = 400;
	const T = {E:0,G:1,B:2,Q:3,U:4,PT:5,PB:6,C:7,F:8,CA:9,P:10};
	const LEVEL = [];
	(function buildLevel(){
		const H = 17, W = 240;
		for(let y=0;y<H;y++){ LEVEL[y] = Array(W).fill(T.E); }
		for(let x=0;x<W;x++){ LEVEL[15][x] = T.G; LEVEL[16][x] = T.G; }
		for(let x=6;x<10;x++) LEVEL[12][x]=T.P;
		for(let x=12;x<16;x++) LEVEL[9][x]=T.P;
		LEVEL[10][21]=T.Q; LEVEL[10][22]=T.B; LEVEL[10][23]=T.Q; LEVEL[10][24]=T.B; LEVEL[10][25]=T.Q;
		LEVEL[6][23]=T.C;
		for (let h=0; h<3; h++){ LEVEL[14-h][35]=T.PT; LEVEL[15-h][36]=T.PB; }
		for (let h=0; h<4; h++){ LEVEL[14-h][46]=T.PT; LEVEL[15-h][47]=T.PB; }
		for (let h=0; h<5; h++){ LEVEL[14-h][60]=T.PT; LEVEL[15-h][61]=T.PB; }
		for(let x=70;x<78;x++) LEVEL[10][x]=(x%2?T.B:T.Q);
		[18,19,20,28,29,30,74,75,76,100,101,102].forEach(x=>LEVEL[8][x]=T.C);
		for(let x=90;x<110;x++) LEVEL[11][x]=T.P;
		for(let i=0;i<6;i++){ for(let y=0;y<=i;y++){ LEVEL[15-y][130+i]=T.G; } }
		for(let i=0;i<6;i++){ for(let y=0;y<6-i;y++){ LEVEL[15-y][140+i]=T.G; } }
		for(let x=170;x<240;x++){ LEVEL[15][x]=T.G; LEVEL[16][x]=T.G; }
		for(let y=3;y<=14;y++) LEVEL[y][FLAG_X]=T.F;
		for(let y=12;y<=14;y++) for(let x=FLAG_X+6;x<FLAG_X+14;x++) LEVEL[y][x]=T.CA;
	})();
	const enemies = [
		{ x: 28*TILE, y: 13*TILE, vx: -1.0, vy:0, w:22, h:22, alive:true },
		{ x: 48*TILE, y: 13*TILE, vx: -0.9, vy:0, w:22, h:22, alive:true },
		{ x: 95*TILE, y: 9*TILE, vx: -1.1, vy:0, w:22, h:22, alive:true },
	];
	const playerStart = { x: 2*TILE, y: 12*TILE };
	const player = { x: playerStart.x, y: playerStart.y, w: 22, h: 28, vx: 0, vy: 0, onGround: false, coins: 0, lives: 3, invulUntil: 0, state: 'playing' };
	const camera = { x: 0, y: 0 };
	const keys = new Set(); let wantLeft=false, wantRight=false, wantJump=false;
	const canvas = document.getElementById('game'); const ctx = canvas.getContext('2d');
	const coinsEl = document.getElementById('coins'); const livesEl = document.getElementById('lives'); const timeEl = document.getElementById('time');
	const overlay = document.getElementById('overlay');
	let startTime = performance.now(); let elapsed = 0; let countdown = WORLD_TIME;
	function aabb(a,b){ return !(a.x+a.w<=b.x || b.x+b.w<=a.x || a.y+a.h<=b.y || b.y+b.h<=a.y); }
	function now(){ return performance.now(); }
	function tileAt(px, py){ const tx = Math.floor(px / TILE); const ty = Math.floor(py / TILE); if (ty < 0 || ty >= LEVEL.length || tx < 0 || tx >= LEVEL[0].length) return T.G; return LEVEL[ty][tx]; }
	function isSolid(t){ return t===T.G || t===T.B || t===T.U || t===T.PT || t===T.PB || t===T.P; }
	function setTile(tx, ty, t){ if (ty<0 || ty>=LEVEL.length || tx<0 || tx>=LEVEL[0].length) return; LEVEL[ty][tx] = t; }
	function rectCollideAndResolve(entity){
		entity.vy = Math.min(entity.vy + 0.9, 18);
		entity.x += entity.vx;
		let collidedX = false;
		const bboxX = { x: entity.x, y: entity.y, w: entity.w, h: entity.h };
		const minTx = Math.floor((bboxX.x)/TILE)-1;
		const maxTx = Math.floor((bboxX.x+bboxX.w)/TILE)+1;
		const minTy = Math.floor((bboxX.y)/TILE)-1;
		const maxTy = Math.floor((bboxX.y+bboxX.h)/TILE)+1;
		for (let ty=minTy; ty<=maxTy; ty++){
			for (let tx=minTx; tx<=maxTx; tx++){
				const t = (LEVEL[ty] && LEVEL[ty][tx]) ?? T.E;
				if (!isSolid(t)) continue;
				const tileRect = { x: tx*TILE, y: ty*TILE, w: TILE, h: TILE };
				if (aabb(bboxX, tileRect)){
					if (entity.vx > 0){ entity.x = tileRect.x - entity.w; }
					else if (entity.vx < 0){ entity.x = tileRect.x + tileRect.w; }
					entity.vx = 0; collidedX = true; bboxX.x = entity.x;
				}
			}
		}
		entity.y += entity.vy;
		let collidedY = false;
		const bboxY = { x: entity.x, y: entity.y, w: entity.w, h: entity.h };
		const minTx2 = Math.floor((bboxY.x)/TILE)-1;
		const maxTx2 = Math.floor((bboxY.x+bboxY.w)/TILE)+1;
		const minTy2 = Math.floor((bboxY.y)/TILE)-1;
		const maxTy2 = Math.floor((bboxY.y+bboxY.h)/TILE)+1;
		for (let ty=minTy2; ty<=maxTy2; ty++){
			for (let tx=minTx2; tx<=maxTx2; tx++){
				const t = (LEVEL[ty] && LEVEL[ty][tx]) ?? T.E;
				if (!isSolid(t)) continue;
				const tileRect = { x: tx*TILE, y: ty*TILE, w: TILE, h: TILE };
				if (aabb(bboxY, tileRect)){
					if (entity.vy > 0){ entity.y = tileRect.y - entity.h; entity.vy = 0; collidedY = true; }
					else if (entity.vy < 0){ entity.y = tileRect.y + tileRect.h; entity.vy = 0; collidedY = true;
						if (entity===player){
							const hitTx = tx, hitTy = ty;
							const tt = tileAt(hitTx*TILE+1, hitTy*TILE+1);
							if (tt===T.Q){ setTile(hitTx, hitTy, T.U); spawnCoin(hitTx*TILE+8, hitTy*TILE-4); player.coins += 1; coinsEl.textContent = player.coins; }
						}
					}
					bboxY.y = entity.y;
				}
			}
		}
		return { collidedX, collidedY };
	}
	function spawnCoin(x,y){ tempParticles.push({x,y,vy:-2,life:40,type:'coin'}); }
	const tempParticles = [];
	function reset(status='playing'){
		player.x = playerStart.x; player.y = playerStart.y; player.vx=0; player.vy=0; player.onGround=false; player.state = status; camera.x=0; camera.y=0;
		startTime = performance.now(); elapsed = 0; countdown = WORLD_TIME; hideOverlay();
	}
	function showOverlay(text){ overlay.textContent = text; overlay.style.display = 'flex'; }
	function hideOverlay(){ overlay.style.display = 'none'; }
	function draw(){
		ctx.fillStyle = '#87CEEB'; ctx.fillRect(0,0,canvas.width,canvas.height);
		const scaleX = canvas.width/(VIEW_W*TILE); const scaleY = canvas.height/(VIEW_H*TILE); const scale = Math.min(scaleX, scaleY);
		ctx.save(); ctx.scale(scale, scale); ctx.translate(-camera.x, -camera.y);
		ctx.fillStyle = '#7dc77d'; for (let i=0;i<10;i++){ const hx = i*380; ctx.beginPath(); ctx.arc(hx+120, 15*TILE, 90, Math.PI, 0); ctx.fill(); }
		for (let y=0;y<LEVEL.length;y++){ for (let x=0;x<LEVEL[0].length;x++){ const t = LEVEL[y][x]; if (t===T.E) continue; const px = x*TILE, py = y*TILE;
			switch(t){
				case T.G: ctx.fillStyle = '#8B4513'; ctx.fillRect(px,py,TILE,TILE); ctx.fillStyle = '#5e2f0e'; ctx.fillRect(px,py+TILE-8,TILE,8); break;
				case T.B: ctx.fillStyle = '#b2641a'; ctx.fillRect(px,py,TILE,TILE); ctx.strokeStyle = '#5a2f0c'; ctx.lineWidth = 2; ctx.strokeRect(px+2,py+2,TILE-4,TILE-4); break;
				case T.Q: ctx.fillStyle = '#f2c840'; ctx.fillRect(px,py,TILE,TILE); ctx.fillStyle = '#955c00'; ctx.fillRect(px+2,py+2,TILE-4,TILE-4); ctx.fillStyle = '#fff'; ctx.font = 'bold 20px system-ui'; ctx.fillText('?', px+9, py+23); break;
				case T.U: ctx.fillStyle = '#cdb79e'; ctx.fillRect(px,py,TILE,TILE); break;
				case T.PT: ctx.fillStyle = '#2ca24d'; ctx.fillRect(px,py,TILE,TILE); ctx.fillStyle='#1b6e32'; ctx.fillRect(px,py+TILE-6,TILE,6); break;
				case T.PB: ctx.fillStyle = '#1b6e32'; ctx.fillRect(px,py,TILE,TILE); break;
				case T.C: ctx.fillStyle = '#ffd14a'; ctx.beginPath(); ctx.arc(px+TILE/2,py+TILE/2,8,0,Math.PI*2); ctx.fill(); break;
				case T.F: ctx.fillStyle='#e5e5e5'; ctx.fillRect(px+TILE/2-2, py, 4, TILE); break;
				case T.CA: ctx.fillStyle='#c23f3f'; ctx.fillRect(px,py,TILE,TILE); break;
				case T.P: ctx.fillStyle='#a87f4b'; ctx.fillRect(px,py,TILE,TILE/3); ctx.fillStyle='#6b4b2a'; ctx.fillRect(px,py+TILE/3,TILE,4); break;
			}
		}}
		for (let y=0;y<LEVEL.length;y++){ for (let x=0;x<LEVEL[0].length;x++){ if (LEVEL[y][x]===T.C){ const px=x*TILE, py=y*TILE; ctx.fillStyle='#ffd14a'; ctx.beginPath(); ctx.arc(px+TILE/2,py+TILE/2,8,0,Math.PI*2); ctx.fill(); }}}
		enemies.forEach(e=>{ if (!e.alive) return; ctx.fillStyle = '#8a4b2a'; ctx.fillRect(e.x, e.y, e.w, e.h); ctx.fillStyle = '#fff'; ctx.fillRect(e.x+4, e.y+6, 6,6); ctx.fillRect(e.x+e.w-10, e.y+6, 6,6); });
		ctx.save(); ctx.translate(player.x+player.w/2, player.y); ctx.scale(player.vx>=0?1:-1, 1);
		ctx.fillStyle='#ff6a00'; ctx.fillRect(-player.w/2, 0, player.w, player.h);
		ctx.fillStyle='#f2d3b2'; ctx.fillRect(-player.w/2+3, -10, player.w-6, 10);
		ctx.fillStyle='#222'; ctx.fillRect(2, -8, 3,6);
		ctx.restore();
		tempParticles.forEach(p=>{ if (p.type==='coin'){ ctx.fillStyle='#ffd14a'; ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill(); } });
		ctx.restore();
	}
	function update(dt){
		if (player.state!=='playing') return;
		elapsed += dt/1000; const left = Math.max(0, WORLD_TIME - Math.floor(elapsed)); if (left !== countdown){ countdown = left; timeEl.textContent = countdown; if (countdown===0){ killPlayer(); } }
		let ax = 0; if (wantLeft) ax -= 0.8; if (wantRight) ax += 0.8; player.vx += ax; player.vx *= 0.85; if (Math.abs(player.vx) > 4.2){ player.vx = 4.2 * Math.sign(player.vx); }
		if (wantJump && player.onGround){ player.vy = -14.5; player.onGround = false; }
		collectCoins();
		const beforeY = player.y; const col = rectCollideAndResolve(player); player.onGround = col.collidedY && player.vy===0 && player.y > beforeY;
		for (const e of enemies){
			if (!e.alive) continue;
			e.vy = Math.min(e.vy + 0.9, 18); e.x += e.vx;
			const frontX = e.vx>0 ? e.x+e.w+1 : e.x-1; const aheadTop = tileAt(frontX, e.y+2); const aheadMid = tileAt(frontX, e.y+e.h-2);
			if (isSolid(aheadTop) || isSolid(aheadMid)){ e.x -= e.vx; e.vx *= -1; }
			e.y += e.vy;
			const belowLeft = tileAt(e.x+2, e.y+e.h+1); const belowRight = tileAt(e.x+e.w-2, e.y+e.h+1);
			if (isSolid(belowLeft)||isSolid(belowRight)){ e.y = Math.floor((e.y+e.h)/TILE)*TILE - e.h; e.vy = 0; }
			const footFrontX = e.vx>0 ? e.x+e.w+2 : e.x-2; const belowFront = tileAt(footFrontX, e.y+e.h+1);
			if (!isSolid(belowFront)){ e.vx *= -1; }
			if (aabb({x:player.x,y:player.y,w:player.w,h:player.h},{x:e.x,y:e.y,w:e.w,h:e.h})){
				if (player.vy>0 && player.y+player.h-4 <= e.y){ e.alive=false; player.vy = -14.5*0.55; spawnParticleBurst(e.x+e.w/2, e.y); }
				else{ hitPlayer(); }
			}
		}
		const targetCamX = Math.max(0, Math.min(player.x - (VIEW_W*TILE)/4, (LEVEL[0].length*TILE) - VIEW_W*TILE));
		camera.x += (targetCamX - camera.x) * 0.15; camera.y = 0;
		const playerTileX = Math.floor((player.x+player.w/2)/TILE);
		if (playerTileX >= 220 && player.y < 14*TILE){ win(); }
		if (player.y > (LEVEL.length+4)*TILE){ killPlayer(); }
		for (const p of tempParticles){ p.x += 0; p.y += p.vy; p.life--; } while (tempParticles.length && tempParticles[0].life<=0) tempParticles.shift();
	}
	function collectCoins(){
		const tilesToCheck = [
			[Math.floor((player.x+player.w/2)/TILE), Math.floor((player.y+player.h/2)/TILE)],
			[Math.floor((player.x+4)/TILE), Math.floor((player.y+player.h/2)/TILE)],
			[Math.floor((player.x+player.w-4)/TILE), Math.floor((player.y+player.h/2)/TILE)],
		];
		for (const [tx,ty] of tilesToCheck){
			if (LEVEL[ty] && LEVEL[ty][tx]===T.C){
				setTile(tx,ty,T.E); player.coins += 1; coinsEl.textContent = player.coins; spawnCoin(tx*TILE+TILE/2, ty*TILE+TILE/2);
			}
		}
	}
	function hitPlayer(){ const t = performance.now(); if (t < player.invulUntil || player.state!=='playing') return; player.invulUntil = t + 1500; player.lives -= 1; livesEl.textContent = player.lives; if (player.lives <= 0){ player.state = 'dead'; showOverlay('Game Over - 按 R 重开'); } }
	function killPlayer(){ if (player.state!=='playing') return; player.state='dead'; showOverlay('Time Up - 按 R 重开'); }
	function win(){ player.state='win'; showOverlay('You Win! 按 R 重玩'); }
	function spawnParticleBurst(x,y){ for (let i=0;i<12;i++){ tempParticles.push({x:x+(Math.random()*12-6), y:y, vy:-2-Math.random()*2, life:30+Math.random()*20, type:'coin'}); } }
	window.addEventListener('keydown', (e)=>{ if (['ArrowLeft','ArrowRight','ArrowUp','Space'].includes(e.code)) e.preventDefault();
		if (e.code==='ArrowLeft' || e.code==='KeyA') wantLeft=true;
		if (e.code==='ArrowRight' || e.code==='KeyD') wantRight=true;
		if (e.code==='Space' || e.code==='KeyK' || e.code==='ArrowUp' || e.code==='KeyW') wantJump=true;
		if (e.code==='KeyP'){ if (player.state==='playing'){ player.state='paused'; showOverlay('已暂停 (P 继续)'); } else if (player.state==='paused'){ player.state='playing'; hideOverlay(); } }
		if (e.code==='KeyR'){ reset('playing'); }
	});
	window.addEventListener('keyup', (e)=>{ if (e.code==='ArrowLeft' || e.code==='KeyA') wantLeft=false; if (e.code==='ArrowRight' || e.code==='KeyD') wantRight=false; if (e.code==='Space' || e.code==='KeyK' || e.code==='ArrowUp' || e.code==='KeyW') wantJump=false; });
	const stick = document.getElementById('stick'); const jumpBtn = document.getElementById('jump');
	function bindDir(el, dir){ function set(v){ if (dir==='left') wantLeft = v; if (dir==='right') wantRight = v; } el.addEventListener('touchstart', e=>{ e.preventDefault(); set(true); }, {passive:false}); el.addEventListener('touchend', e=>{ e.preventDefault(); set(false); }, {passive:false}); el.addEventListener('touchcancel', e=>{ e.preventDefault(); set(false); }, {passive:false}); }
	Array.from(stick.querySelectorAll('.dir')).forEach(d=>{ bindDir(d, d.dataset.dir); });
	jumpBtn.addEventListener('touchstart', e=>{ e.preventDefault(); wantJump=true; }, {passive:false});
	jumpBtn.addEventListener('touchend', e=>{ e.preventDefault(); wantJump=false; }, {passive:false});
	jumpBtn.addEventListener('touchcancel', e=>{ e.preventDefault(); wantJump=false; }, {passive:false});
	let last = performance.now();
	function frame(t){ const dt = Math.min(32, t-last); last=t; update(dt); draw(); requestAnimationFrame(frame); }
	requestAnimationFrame(frame);
	coinsEl.textContent = player.coins; livesEl.textContent = player.lives; timeEl.textContent = 400;
	canvas.addEventListener('pointerdown', ()=>canvas.focus());
	canvas.addEventListener('touchstart', ()=>canvas.focus());
})();
</script>
</body>
</html>